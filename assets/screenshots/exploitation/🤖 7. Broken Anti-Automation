# Cryptographic Failures

**Category overview**  
Cryptographic Failures occur when cryptography is used incorrectly, weak algorithms are accepted, secrets are stored or transmitted insecurely, or key management is poor. Symptoms include weak hashing (MD5/sha1), reversible encryption with poor keys, hard-coded secrets, accepting deprecated encodings as security, and lack of integrity or authenticated encryption. Exploitation can lead to credential recovery, forgery, replay attacks, and broader system compromise.

---

## Overview Observed in This Assessment

The following cryptographic weaknesses were identified and validated in a controlled Juice Shop lab:

- **Weird Crypto** — application accepted or relied on weak MD5-based mechanisms for challenge logic.  
- **Easter Egg / Nested Easter Egg** — sensitive string encoded only with Base64 + ROT13, easily reversible.  
- **User Credentials** — user password or challenge secrets recoverable due to weak MD5 hashing and lack of salts.

Each finding below contains concise Steps to Reproduce, Impact, and Mitigations.

---

### A Weird Crypto (Weak Hashing Accepted)

**What it is**  
The application accepts or relies on weak cryptographic hashes (MD5, SHA-1) for password storage, challenge gating, or integrity checks, allowing trivial collisions or preimage attacks.

**Observed in lab**  
A challenge required submitting an MD5-related payload; the system accepted MD5 digests and in some cases verified values client-side or without salt, enabling trivial offline cracking.

**Steps to Reproduce (concise)**  
1. Identify functionality relying on MD5 (challenge prompt, stored hash, or API that returns digest).  
2. Compute or retrieve MD5 values for candidate inputs (local tooling or online generators).  
3. Use known collisions or rainbow tables to find inputs matching the accepted MD5 digest.

**Impact**  
- Offline recovery of original inputs or passwords via rainbow tables.  
- Forged tokens or bypass of integrity checks that use weak hashes.  
- Easier credential cracking leading to account takeover.

**Mitigations**  
- Replace MD5/SHA-1 with strong, adaptive hashing (Argon2, bcrypt, or PBKDF2 with adequate iterations).  
- Use per-user salts and store salt alongside the hash.  
- Avoid using plain hashes as authentication tokens; use HMAC with a secret key or authenticated encryption where integrity is required.

---

### B Easter Egg / Nested Easter Egg (Poor Encoding as "Security")

**What it is**  
Encoding (Base64, ROT13, simple reversible transforms) is used where encryption or secrecy is expected, making secrets trivial to decode.

**Observed in lab**  
A hidden secret was protected only by Base64 encoding followed by ROT13; decoding returned the original secret immediately.

**Steps to Reproduce (concise)**  
1. Locate the encoded string in the app or challenge payload.  
2. Apply Base64 decode, then ROT13 (or the reverse order used by the app).  
3. Read the revealed secret or token.

**Impact**  
- Immediate disclosure of secrets, flags, or configuration strings.  
- Low barrier to automated discovery and exploitation.  
- Misplaced confidence in obfuscation that obstructs detection efforts.

**Mitigations**  
- Never treat reversible encodings as security. Protect secrets with proper cryptography (authenticated encryption) and access controls.  
- Store secrets in a secure vault and return only tokens or references with limited lifetime.  
- Remove hard-coded or embedded secrets from code and repositories.

---

### C User Credentials (Recoverable Hashed Passwords)

**What it is**  
Passwords or sensitive tokens are hashed with weak algorithms, without salts or with fast hashes, making them vulnerable to brute-force or rainbow-table attacks.

**Observed in lab**  
A user record used MD5-hashed passwords (or similarly weak scheme) with no per-user salt; recovered hashes were cracked to retrieve plaintext passwords.

**Steps to Reproduce (concise)**  
1. Extract password hash from exposed data (database dump, backup, or endpoint).  
2. Use offline cracking tools (hashcat, john) with common wordlists and MD5 mode.  
3. Recover plaintext and validate login with recovered credentials.

**Impact**  
- Account takeover for cracked accounts.  
- Credential reuse implications if users reuse passwords elsewhere.  
- Escalation of privileges if cracked accounts have higher rights.

**Mitigations**  
- Use adaptive, slow password hashing (Argon2id, bcrypt with sufficient cost) and unique per-user salts.  
- Implement password strength checks and breach-detection (block known-compromised passwords).  
- Use multi-factor authentication to limit impact of credential theft.  
- Rotate secrets and force password resets when weak hashing is discovered.

---

## Detection and Logging Recommendations

- Alert on use of deprecated hash functions in code scans (MD5/SHA-1) and on storage of unsalted hashes.  
- Monitor for access patterns that indicate offline cracking preparation (mass hash exports, large downloads of user tables).  
- Log attempts to use weak-crypto-dependent endpoints and flag unusual decoding/encoding activity.

---

## Hardening Checklist

- Migrate all password storage to Argon2id or bcrypt with per-user salts and appropriate cost factors.  
- Replace any business logic or tokens that rely on plain hashes with HMAC or authenticated encryption (AES-GCM).  
- Remove reversible encodings used as “protection”; use proper encryption and key management.  
- Use a secrets vault (HashiCorp Vault, Azure Key Vault, AWS Secrets Manager) for keys and rotate them regularly.  
- Run automated cryptographic checks in CI (detect MD5/SHA-1, hard-coded keys, weak RNG usage).  
- Enforce MFA and breach-detection controls to reduce impact of any recovered credentials.

