# Vulnerable Components and Legacy Code

**Category overview**  
Vulnerable Components and Legacy Code covers risks introduced by outdated libraries, unmaintained dependencies, and legacy application code paths that no longer receive security updates or modern hardening. These components often contain known vulnerabilities (CVE), insecure defaults, and compatibility quirks that attackers can exploit. Impact ranges from information disclosure to remote code execution depending on the component and its role.

---

## Overview Observed in This Assessment

The following issues were discovered and validated in a controlled Juice Shop lab:

- **Legacy Typosquatting** — an outdated dependency (`epilogue-js`) or similarly named package was present, exposing known vulnerabilities or accidental malicious packages.  
- **Deprecated Interface** — legacy API endpoints remained reachable and accepted inputs not validated by current logic, opening an alternate, weaker attack surface.

Each finding below contains concise Steps to Reproduce, Impact, and Mitigations.

---

### A Legacy Typosquatting (Outdated / Malicious Dependency)

**What it is**  
A dependency in the software supply chain is outdated, unmaintained, or a typosquatted package (package name confusion) that may contain known vulnerabilities or malicious code. Attackers exploit these by leveraging known CVEs or injecting malicious updates into the ecosystem.

**Observed in lab**  
Package manifests and backup artifacts revealed an `epilogue-js` dependency (or similarly suspicious package) pinned in package.json. The package had known security issues in archived advisories or its presence suggested weak dependency hygiene.

**Steps to Reproduce (concise)**  
1. Inspect package manifests (package.json, package-lock.json) or downloaded dependencies.  
2. Lookup package versions against vulnerability databases or advisories.  
3. If the package is typosquatted, note unexpected or similarly named modules and search for known malicious indicators.

**Impact**  
- Execution of vulnerable or malicious code during runtime or build processes.  
- Supply-chain compromise enabling backdoors, credential exfiltration, or remote command execution.  
- Difficult-to-detect persistence via transitive dependencies.

**Mitigations**  
- Audit dependencies regularly and remove or update packages with known vulnerabilities.  
- Use lockfiles and verified registries; enable dependency integrity checks (npm shrinkwrap / package-lock integrity).  
- Employ automated dependency-scanning tools (SCA) in CI to block known-vulnerable versions.  
- Adopt allow-lists for critical packages and review new transitive dependencies before accepting them.

---

### B Deprecated Interface (Legacy API Still Accessible)

**What it is**  
Old APIs, maintenance endpoints, or legacy code paths remain enabled in production, and they accept inputs processed by older, less-secure logic. These interfaces may lack modern validation, authentication, or logging.

**Observed in lab**  
A legacy API endpoint (XML-based or otherwise) was reachable and processed requests with outdated parsers or validation, enabling misuse that current endpoints prevented.

**Steps to Reproduce (concise)**  
1. Enumerate potential legacy endpoints via sitemaps, source comments, or static assets.  
2. Send crafted requests tailored to legacy parsers and observe server responses.  
3. Compare behavior with modern endpoints to identify bypasses.

**Impact**  
- Alternate attack surface that bypasses current security controls.  
- Enables format-specific attacks (XXE, injection) or logic flaws unaddressed in current code.  
- Increases maintenance burden and complicates incident response.

**Mitigations**  
- Remove or disable deprecated endpoints as part of deployment hardening.  
- If retention is necessary, gate
