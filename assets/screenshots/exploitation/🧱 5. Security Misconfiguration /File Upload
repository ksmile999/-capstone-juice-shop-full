# Security Misconfiguration and File Upload Controls

**Category overview**  
Security misconfiguration covers improper settings in the application, platform, or server that create unintended attack surfaces. File upload weaknesses are a common subset where insufficient validation, permissive parsing, or improper storage allow attackers to upload and execute or exfiltrate data. Exploitation can lead to remote code execution, data leakage, privilege escalation, and persistence.

---

## Overview Observed in This Assessment

The assessment identified and exploited several misconfiguration and file-upload issues in a controlled Juice Shop lab:

- **Upload Type Bypass** — MIME/type checks were bypassed by manipulating headers and extensions.  
- **Upload Size Bypass** — Content-Length and client-side size checks were circumvented to upload oversized payloads.  
- **Deprecated Interface** — A legacy XML parser endpoint accepted crafted uploads that bypassed modern validation.  
- **XML Injection** — Uploaded XML was processed unsafely, enabling injection and unintended server-side behavior.

Each finding below contains concise Steps to Reproduce, Impact, and Mitigations.

---

### A Upload Type Bypass (MIME/Extension Evasion)

**What it is**  
Server trusts client-provided MIME type or file extension and fails to inspect file contents, allowing dangerous files (scripts, archives) to be uploaded and served.

**Observed in lab**  
An attacker changed the `Content-Type` header and filename extension (e.g., `image.jpg`) while uploading a PHP/HTML payload. The server accepted and stored the file under a public assets path.

**Steps to Reproduce (concise)**  
1. Craft a payload file with malicious content (e.g., HTML/JS or server-side script).  
2. Intercept upload request and set `Content-Type: image/jpeg` and filename `payload.jpg`.  
3. Forward request and verify file is stored and accessible via a predictable URL.

**Impact**  
- Persistent XSS if HTML/JS is served; RCE where server executes uploaded scripts.  
- Malware or shells placed on the server enabling full compromise.  
- Defacement and large-scale client-side exploitation.

**Mitigations**  
- Validate file type server-side using content inspection (magic bytes) not headers/extension.  
- Restrict allowed types and implement whitelist checking.  
- Store uploads outside the web root and serve via a proxy that enforces content-type and sanitization.  
- Rename stored files to non-guessable IDs and apply safe content-disposition headers.

---

### B Upload Size Bypass (Content-Length / Client-side Check Evasion)

**What it is**  
Server relies on client-side or easily-manipulated headers to enforce size limits, allowing attackers to upload very large files or overload processing components.

**Observed in lab**  
The client-side UI prevented >2MB uploads, but the server accepted larger files when `Content-Length` was adjusted and the request forwarded directly.

**Steps to Reproduce (concise)**  
1. Prepare a large payload exceeding client-side limit.  
2. Intercept the upload and modify/remove `Content-Length` or chunk the request to bypass checks.  
3. Forward and confirm the large file is stored/processed.

**Impact**  
- Denial-of-service via resource exhaustion (disk, memory, CPU).  
- Uploading very large payloads for later retrieval/exfiltration.  
- Facilitates other attacks (embedding large archives with malicious content).

**Mitigations**  
- Enforce server-side size limits and reject oversized requests at the web server or application gateway.  
- Use streaming file handlers and quota controls to avoid loading entire files into memory.  
- Validate size post-upload and delete files exceeding allowed thresholds.  
- Monitor and rate-limit upload endpoints.

---

### C Deprecated Interface (Legacy Parser / Insecure Upload Endpoint)

**What it is**  
Legacy or deprecated endpoints remain reachable and accept inputs that are processed by outdated, insecure parsers lacking current protections.

**Observed in lab**  
A legacy XML upload endpoint intended for internal integrations accepted crafted uploads that bypassed newer validation logic and triggered backend processing with unsafe assumptions.

**Steps to Reproduce (concise)**  
1. Discover legacy endpoints via source hints, docs, or enumeration.  
2. Craft an upload payload tailored to the old parser’s expectations.  
3. POST the payload and observe backend actions or data exposure.

**Impact**  
- Alternate attack surface not covered by modern validation/monitoring.  
- Enables XML-based or format-specific injections, logic abuse, or data exfiltration.  
- Difficult to detect if monitoring focuses on current APIs.

**Mitigations**  
- Disable or remove deprecated interfaces; enforce a strict deprecation lifecycle.  
- Apply the same validation, auth, and logging to any legacy endpoints that must remain.  
- Harden legacy parsers (disable external entity resolution, enforce schemas).

---

### D XML Injection (Unsafe XML Processing)

**What it is**  
Unsafe handling of uploaded XML (e.g., no XXE protections, missing schema validation) allows injection of external entities, large payloads, or malformed structures to manipulate server behavior.

**Observed in lab**  
Uploaded XML containing crafted entity declarations and unexpected nodes caused the application to fetch internal resources and process unintended data paths.

**Steps to Reproduce (concise)**  
1. Create an XML payload using external entity references or unexpected elements.  
2. Upload via the designated endpoint or legacy interface.  
3. Observe server resolving entities or behaving according to injected structure.

**Impact**  
- XXE leads to disclosure of local files, SSRF to internal services, or remote resource retrieval.  
- Application logic manipulation and potential privilege escalation.  
- Data leakage and expanded attack surface inside internal networks.

**Mitigations**  
- Disable XML external entities and DTD processing in XML parsers.  
- Validate XML against strict schemas and reject unexpected nodes.  
- Prefer JSON or safer formats where appropriate; sanitize and canonicalize inputs.

---

## Detection and Logging Recommendations

- Log upload attempts with file metadata (declared MIME, filename, actual detected type, size, user).  
- Alert on discrepancies between declared and detected file types or attempts to upload executable content.  
- Monitor legacy endpoints and flag uploads to deprecated routes for review.  
- Track large or repeated upload activity per account/IP and apply rate-limits.

---

## Hardening Checklist

- Enforce server-side validation for file type, size, and content (magic bytes + whitelist).  
- Store uploads outside the web root and serve safely with sanitizing proxies.  
- Rename files to non-guessable IDs and block execution permissions on storage.  
- Disable or remove legacy upload endpoints; apply modern parser protections where unavoidable.  
- Disable XML external entities, validate against schemas, and use safe parsing libraries.  
- Add quotas, streaming handling, and monitoring on upload endpoints to prevent DoS.
